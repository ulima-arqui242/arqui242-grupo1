# 3.5. Elección de Tecnología

**Titulo**


**Alternativas:**


**Criterios de elección:**


**Decisión:**


**Sustento:**

## Módulo de Registro y Autenticación

## Módulo de Gestión de Perfiles

## Módulo de Gestión de Citas

## Módulo de Historial Médico

## Módulo de Teleconsulta

## Módulo de Chatbot de Diagnóstico

## Módulo de Chat y Comunicación

## Módulo de Gestión de Recetas y Medicamentos

### Decisión 1 (Elección de Tecnología)

**Título**:  
   - Elección entre Lenguaje Tipado vs No Tipado para todo el proyecto

**Contexto**:  
   - El proyecto busca desarrollar un sistema de gestión para clínicas. El equipo está conformado por estudiantes con experiencia en JavaScript, Typescript y Python. Si bien la velocidad de desarrollo es importante, se necesita un código que sea fácil de mantener a medida que el sistema crezca y se vuelva más complejo, ya que cualquier error podría impactar directamente en la experiencia de los usuarios (médicos y pacientes).

**Alternativas**:  
1. **Lenguaje No Tipado (JavaScript y Python)**  
   - Permite un desarrollo más rápido al no requerir tipado estricto, lo que facilita las primeras fases del proyecto.
   - JavaScript es ampliamente conocido y tiene una curva de aprendizaje más corta, lo que podría acelerar la entrega inicial.
   - Sin embargo, la falta de tipado puede aumentar el riesgo de errores en producción, especialmente en un proyecto que manejará datos sensibles de pacientes y citas.
2. **Lenguaje Tipado (TypeScript)**  
   - TypeScript proporciona tipado estático, lo que ayuda a detectar errores antes de que el código se ejecute, lo que resulta crucial en un sistema que manejará información médica sensible.
   - Facilita la documentación del código y mejora la mantenibilidad, lo que es beneficioso para el crecimiento del sistema a largo plazo.

**Criterios de Elección**:  
   - Reducir al mínimo los errores en producción, especialmente al manejar datos médicos sensibles.
   - El sistema debe poder escalar sin que el código se vuelva difícil de gestionar o corregir.
   - Asegurar que el equipo pueda trabajar de forma eficiente sin una curva de aprendizaje demasiado pronunciada.

**Decisión**:  
   - Se elige TypeScript como el lenguaje principal para el desarrollo del proyecto.

**Sustento**:  
   - La elección de TypeScript se debe a su capacidad para ofrecer un entorno más seguro y controlado, lo que es esencial para un sistema que maneja datos médicos sensibles. Aunque JavaScript es más rápido al inicio, la seguridad y robustez a largo plazo son cruciales. TypeScript previene errores comunes mediante tipado estático y es compatible con las habilidades del equipo, por lo que no habrá problemas de adopción. En resumen, TypeScript mejora la calidad, seguridad y mantenimiento del sistema conforme este crezca.

---

### Decisión 2 (Modelo de Base de Datos)

**Título**:  
   - Elección entre base de datos relacional vs no relacional para el almacenamiento principal de los datos

**Contexto**:  
   - El sistema debe gestionar datos estructurados, como la información de usuarios, citas y resultados médicos, que están interrelacionados y requieren consistencia e integridad. Además, la base de datos debe soportar consultas complejas entre estas entidades. La escalabilidad y crecimiento del sistema también son importantes, pero el enfoque principal es mantener relaciones claras y estructuradas entre los datos.

**Alternativas**:  
1. **Base de Datos Relacional (PostgreSQL)**  
   - Proporciona un esquema estructurado con soporte para relaciones complejas, ideal para datos que necesitan cumplir con propiedades ACID (consistencia, aislamiento y durabilidad).
   - Facilita la creación de relaciones entre entidades, como pacientes, médicos y citas, lo que es clave para el manejo de información clínica interrelacionada.
2. **Base de Datos No Relacional (MongoDB)**  
   - Ofrece flexibilidad para manejar datos no estructurados y escalabilidad horizontal.
   - No requiere un esquema fijo, lo que puede facilitar cambios en la estructura de los datos, pero no es ideal para mantener la consistencia entre entidades interrelacionadas.

**Criterios de Elección**:  
   - Necesidad de manejar datos estructurados con relaciones claras entre entidades.
   - Garantía de consistencia e integridad de los datos debido a la naturaleza sensible de la información médica.
   - Capacidad para realizar consultas SQL complejas y soporte a largo plazo para el crecimiento del sistema.

**Decisión**:  
   - Se elige PostgreSQL.

**Sustento**:  
   - PostgreSQL es la mejor opción debido a la estructura clara y ordenada que se requiere para manejar datos interrelacionados como usuarios, citas y resultados médicos. La capacidad de definir relaciones entre tablas permite gestionar de manera eficiente la información sensible y garantizar la consistencia de los datos. Además, su soporte para propiedades ACID asegura que las transacciones se manejen de forma segura, lo cual es fundamental para la integridad de la información médica. La naturaleza estructurada del proyecto se beneficia de un sistema relacional que puede escalar a medida que crece, sin sacrificar la estabilidad ni la confiabilidad del esquema de datos.

---

### Decisión 3 (Arquitectura)

**Título**:  
   - Elección entre arquitectura monolítica vs microservicios

**Contexto**:  
   - El sistema está diseñado para gestionar módulos independientes, como el manejo de usuarios, historial médico, citas, y un chatbot. Se espera que el sistema crezca en funcionalidades, incluyendo módulos futuros como analítica, administración, y generación de reportes. Además, cada módulo puede requerir actualizaciones y mejoras continuas sin que esto afecte a los otros. Dada la naturaleza del proyecto, que maneja datos críticos y debe adaptarse a nuevas tecnologías, se busca flexibilidad y escalabilidad. Es importante también considerar los costos de desarrollo e infraestructura, ya que una arquitectura más compleja podría implicar mayores costos de mantenimiento.

**Alternativas**:  
1. **Arquitectura Monolítica**  
   - Simplifica el desarrollo inicial, permitiendo que todo el sistema funcione como una sola aplicación.
   - Ideal para equipos pequeños y proyectos con un alcance limitado, ya que todo se gestiona en una sola base de código.
   - Sin embargo, a medida que el sistema crece, la escalabilidad se vuelve un desafío, ya que cualquier cambio o error en un módulo puede impactar a toda la aplicación.
   - Menores costos iniciales, pero con el tiempo los costos de mantenimiento y actualizaciones podrían aumentar al ser un sistema más rígido.
2. **Arquitectura de Microservicios**  
   - Divide el sistema en pequeños servicios independientes, cada uno responsable de un conjunto específico de funcionalidades.
   - Facilita el escalado y desarrollo modular, permitiendo que cada servicio evolucione o escale sin afectar el resto del sistema.
   - Ofrece una mayor flexibilidad, ya que nuevos módulos pueden añadirse e integrarse sin reestructurar el sistema completo.
   - Inicialmente puede ser más costoso debido a la necesidad de gestionar y mantener múltiples servicios y bases de datos, pero a largo plazo es más eficiente y adaptable.

**Criterios de Elección**:  
   - Capacidad de añadir nuevos módulos y funcionalidades sin interrumpir el sistema existente.
   - Independencia entre los diferentes módulos del sistema, lo que permite desarrollos y actualizaciones específicas por áreas.
   - Asegurar que los costos de mantenimiento sean manejables y proporcionales a la flexibilidad que se obtiene.
   - Capacidad para soportar alto tráfico y procesamiento sin que un fallo en un servicio afecte a los demás.

**Decisión**:  
   - Se elige una arquitectura de Microservicios.

**Sustento**:  
   - Se eligió una arquitectura de microservicios porque ofrece mayor flexibilidad y escalabilidad para manejar módulos independientes como usuarios, citas y chatbot. Esto permite desarrollar y actualizar cada módulo sin afectar el sistema completo, mejorando la modularidad y el rendimiento. Aunque los costos iniciales pueden ser mayores, a largo plazo resulta más eficiente y adaptable, lo que se alinea mejor con los objetivos de crecimiento y evolución del proyecto.

---

### Decisión 4 (Framework de Frontend)

**Título**:  
   - Elección entre Next.js vs Angular para el frontend

**Contexto**:  
   - El equipo está dividido en cuanto a experiencia: algunos miembros tienen un buen dominio de React, mientras que otros están más familiarizados con Angular. Sin embargo, no podíamos hacer una comparación justa entre React (una librería) y Angular (un framework), por lo que decidimos considerar Next.js como una opción comparable, ya que es un framework basado en React que ofrece herramientas adicionales para estructurar mejor el desarrollo. La aplicación debe ser rápida y eficiente, tanto en su desarrollo como en su rendimiento, ya que será usada por médicos y pacientes en tiempo real. La capacidad de manejar rutas y la facilidad para escalar también son fundamentales.

**Alternativas**:  
1. **Next.js**  
   - Basado en React, es sencillo de implementar y ofrece buena escalabilidad para aplicaciones que requieren una estructura más sólida.
   - Facilita el desarrollo rápido y es flexible para un equipo que ya tiene experiencia en React.

2. **Angular**  
   - Un framework completo con muchas funcionalidades integradas, ideal para aplicaciones grandes.
   - Estructura de carpetas definida y opinionada.
   - Sin embargo, puede ser excesivamente complejo para un proyecto que, aunque tiene potencial de crecimiento, no requiere de toda la estructura pesada de Angular desde el inicio.

**Criterios de Elección**:  
   - Rapidez de la aplicación y capacidad de respuesta en tiempo real.
   - Facilidad de implementación y desarrollo para el equipo, dada la experiencia existente.
   - Escalabilidad a medida que la aplicación crezca en complejidad.

**Decisión**:  
   - Se elige Next.js.

**Sustento**:  
   - Next.js fue seleccionado debido a que el equipo tiene más experiencia en React, lo que facilita la transición y desarrollo. Aunque Angular es un framework robusto, su complejidad es innecesaria para un proyecto que, en esta etapa, busca agilidad y eficiencia. Next.js ofrece la estructura que React no tiene por sí solo, permitiendo que el equipo se enfoque en una implementación más ágil y escalable sin la sobrecarga de un framework más pesado como Angular. Además, su enfoque ligero y su flexibilidad son ideales para una aplicación que necesita ser rápida y adaptable a futuras expansiones.

---

### Decisión 5 (Framework de Backend)

**Título**:  
- Elección entre Express.js vs NestJS para el backend

**Contexto**:  
- El equipo necesita un framework robusto y escalable que permita desarrollar una API modular y bien organizada, con soporte para controladores, middleware y un sistema de inyección de dependencias. También se espera que el backend crezca en complejidad con el tiempo.

**Alternativas**:  
1. **Express.js**  
   - Minimalista y flexible, con una estructura básica.
   - Requiere mayor esfuerzo para organizar proyectos grandes.
2. **NestJS**  
   - Ofrece una arquitectura bien estructurada, basada en controladores y módulos.
   - Proporciona inyección de dependencias, lo que facilita el manejo de la complejidad.

**Criterios de Elección**:  
- Escalabilidad y facilidad de mantenimiento.
- Soporte para modularidad y desarrollo organizado.
- Curva de aprendizaje para el equipo.

**Decisión**:  
- Se elige NestJS.

**Sustento**:  
- NestJS proporciona una arquitectura modular clara y escalable, lo que facilita la gestión de proyectos grandes y complejos. La inyección de dependencias y su estructura bien organizada permiten un desarrollo más eficiente, lo cual es esencial para un backend que necesita soportar una API robusta y en crecimiento.

---

### Decisión 6 (Proveedor de Nube)

**Título**:  
- Elección entre AWS vs Azure como proveedor de nube

**Contexto**:  
- El proyecto necesita una infraestructura en la nube escalable y flexible que soporte tanto bases de datos relacionales como no relacionales, servicios de machine learning, y capacidades de computación para gestionar las diferentes APIs del sistema. El equipo también requiere una solución con buena documentación y soporte para herramientas DevOps. Es importante que el equipo tenga acceso a una variedad de servicios de nube para diferentes necesidades, como almacenamiento, computación y redes.

**Alternativas**:  
1. **AWS (Amazon Web Services)**  
   - Ofrece una amplia gama de servicios de infraestructura, incluyendo soluciones avanzadas para almacenamiento, cómputo, machine learning y bases de datos.
   - Documentación extensa y soporte con una comunidad grande y activa.
   - Bien integrado con servicios como Lambda para serverless, S3 para almacenamiento y RDS para bases de datos relacionales.
2. **Azure**  
   - Ofrece una integración sólida con productos Microsoft, como Active Directory y herramientas de desarrollo como Visual Studio.
   - Soporta múltiples lenguajes de programación y plataformas, y tiene soluciones avanzadas para análisis de datos y machine learning.
   - Es una buena opción si ya se utilizan tecnologías Microsoft en el entorno del equipo.

**Criterios de Elección**:  
- Variedad y flexibilidad de servicios.
- Escalabilidad y facilidad de uso para los desarrolladores.
- Documentación y soporte disponible.
- Costo y facilidad de integración con el stack tecnológico existente.

**Decisión**:  
- Se elige AWS.

**Sustento**:  
- AWS ofrece una mayor variedad de servicios y flexibilidad, lo que permite cubrir todas las necesidades del proyecto, desde bases de datos y almacenamiento hasta servicios serverless y machine learning. La amplia documentación y comunidad hacen que sea más fácil de adoptar por el equipo, y sus servicios como Lambda y S3 ya son bien conocidos por el equipo. Además, AWS tiene una escalabilidad comprobada, lo cual es fundamental para un proyecto que se espera que crezca rápidamente en el tiempo.



## Módulo de Resultados

