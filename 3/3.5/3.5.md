# 3.5. Elección de Tecnología

**Titulo**


**Alternativas:**


**Criterios de elección:**


**Decisión:**


**Sustento:**

## Módulo de Registro y Autenticación

## Módulo de Gestión de Perfiles

## Módulo de Gestión de Citas

## Módulo de Historial Médico

## Módulo de Teleconsulta

## Módulo de Chatbot de Diagnóstico

## Módulo de Chat y Comunicación

## Módulo de Gestión de Recetas y Medicamentos

### Decisión 1 (Elección de Tecnología)

**Título**:  
- Elección entre Lenguaje Tipado vs No Tipado para todo el proyecto

**Contexto**:  
- El equipo está conformado por estudiantes con experiencia en JavaScript, Typescript y Python. Para el proyeco necesitamos robustez y buena mantenibilidad en el código para evitar posibles errores en producción.

**Alternativas**:  
1. **Lenguaje No Tipado (JavaScript y Python)**  
   - Ofrece flexibilidad y agilidad, permitiendo un desarrollo rápido y sin restricciones de tipado.
   - Es ampliamente conocido por el equipo, lo que facilita el proceso inicial.
2. **Lenguaje Tipado (TypeScript)**  
   - Proporciona tipado estático que permite detectar errores en tiempo de compilación.
   - Facilita la documentación y el mantenimiento del código a largo plazo, lo que puede reducir errores críticos en producción.
   - Mejora la escalabilidad del proyecto debido a su estricta definición de tipos y mayor seguridad en el manejo de datos.

**Criterios de Elección**:  
- Robustez y mantenibilidad a largo plazo.
- Control sobre errores y validaciones previas a la ejecución.
- Facilidad de adopción y curva de aprendizaje para el equipo actual.

**Decisión**:  
- Se elige TypeScript.

**Sustento**:  
- TypeScript proporciona una capa adicional de seguridad que permite minimizar errores que JavaScript podría no detectar en tiempo de desarrollo. A pesar de la flexibilidad de JavaScript, la necesidad de un código más seguro y escalable en el tiempo hace que TypeScript sea la mejor opción para un proyecto que crecerá con el tiempo, facilitando la mantenibilidad y reducción de errores críticos.

---

### Decisión 2 (Modelo de Base de Datos)

**Título**:  
- Elección entre base de datos relacional vs no relacional para el almacenamiento de datos

**Contexto**:  
- El sistema requiere manejar datos estructurados, como información de usuarios, transacciones y citas, que deben cumplir con propiedades ACID. También se espera que el sistema crezca y necesite realizar consultas complejas y relaciones entre distintas entidades, lo que hace relevante la consistencia de los datos.

**Alternativas**:  
1. **Base de Datos Relacional (PostgreSQL)**  
   - Proporciona consistencia y soporte para relaciones complejas entre entidades.
   - Ideal para gestionar grandes volúmenes de datos estructurados con consultas SQL.
2. **Base de Datos No Relacional (MongoDB)**  
   - Ofrece flexibilidad y escalabilidad para manejar datos no estructurados.
   - No requiere esquemas fijos, lo que permite cambios rápidos en la estructura de los datos.

**Criterios de Elección**:  
- Consistencia y necesidad de garantizar integridad de los datos.
- Soporte para consultas complejas entre entidades relacionadas.
- Necesidades a largo plazo de escalabilidad y crecimiento del sistema.

**Decisión**:  
- Se elige PostgreSQL.

**Sustento**:  
- La consistencia y la integridad de los datos son aspectos críticos para el proyecto, especialmente al manejar información sensible como la relacionada con usuarios y transacciones. PostgreSQL, con su soporte para relaciones y transacciones ACID, garantiza que los datos sean manejados de manera segura y confiable, cumpliendo con las necesidades del sistema.

---

### Decisión 3 (Arquitectura)

**Título**:  
- Elección entre arquitectura monolítica vs microservicios

**Contexto**:  
- El sistema está diseñado para escalar y manejar varios módulos independientes, como el manejo de usuarios, historial médico, citas y un chatbot. A medida que el sistema crezca, se espera que algunas áreas requieran un desarrollo más ágil e independiente de otras. La empresa también planea integrar nuevos servicios en el futuro.

**Alternativas**:  
1. **Arquitectura Monolítica**  
   - Simplifica el desarrollo y la implementación en las primeras etapas.
   - Fácil de gestionar en equipos pequeños, pero menos flexible a medida que el sistema crece.
2. **Arquitectura de Microservicios**  
   - Permite un desarrollo modular, donde cada servicio puede escalar de manera independiente.
   - Facilita la integración de nuevas funcionalidades sin afectar el resto del sistema.

**Criterios de Elección**:  
- Escalabilidad y flexibilidad a largo plazo.
- Modularidad para facilitar la adición de nuevos servicios.
- Independencia en el desarrollo de diferentes módulos.

**Decisión**:  
- Se elige microservicios.

**Sustento**:  
- La arquitectura de microservicios es ideal para proyectos que tienen la intención de escalar y añadir nuevos módulos de manera independiente. Esta opción ofrece mayor flexibilidad, ya que cada componente del sistema puede ser actualizado o escalado sin afectar el resto de la aplicación, lo cual se alinea con las necesidades de crecimiento del sistema.

---

### Decisión 4 (Framework de Frontend)

**Título**:  
- Elección entre Next.js vs Angular para el frontend

**Contexto**:  
- El equipo necesita construir una interfaz de usuario dinámica y optimizada para SEO. Además, la posibilidad de renderizado del lado del servidor (SSR) y una buena gestión de rutas son fundamentales para el desempeño y la experiencia de usuario.

**Alternativas**:  
1. **Next.js**  
   - Permite renderizado del lado del servidor, lo que mejora el SEO y la velocidad de carga.
   - Sencillo de implementar, basado en React, con buena escalabilidad para aplicaciones web.
2. **Angular**  
   - Proporciona una arquitectura más estructurada con muchas funcionalidades integradas.
   - Puede ser excesivamente complejo para proyectos medianos y pequeños.

**Criterios de Elección**:  
- SEO y velocidad de carga de la aplicación.
- Curva de aprendizaje y flexibilidad en el desarrollo.
- Necesidades a largo plazo de escalabilidad.

**Decisión**:  
- Se elige Next.js.

**Sustento**:  
- Next.js es ideal para optimizar el rendimiento de la aplicación y mejorar el SEO mediante SSR. Además, la simplicidad y flexibilidad de Next.js son una gran ventaja para un equipo que busca agilidad y una implementación eficiente, especialmente en proyectos con un enfoque dinámico.

---

### Decisión 5 (Framework de Backend)

**Título**:  
- Elección entre Express.js vs NestJS para el backend

**Contexto**:  
- El equipo necesita un framework robusto y escalable que permita desarrollar una API modular y bien organizada, con soporte para controladores, middleware y un sistema de inyección de dependencias. También se espera que el backend crezca en complejidad con el tiempo.

**Alternativas**:  
1. **Express.js**  
   - Minimalista y flexible, con una estructura básica.
   - Requiere mayor esfuerzo para organizar proyectos grandes.
2. **NestJS**  
   - Ofrece una arquitectura bien estructurada, basada en controladores y módulos.
   - Proporciona inyección de dependencias, lo que facilita el manejo de la complejidad.

**Criterios de Elección**:  
- Escalabilidad y facilidad de mantenimiento.
- Soporte para modularidad y desarrollo organizado.
- Curva de aprendizaje para el equipo.

**Decisión**:  
- Se elige NestJS.

**Sustento**:  
- NestJS proporciona una arquitectura modular clara y escalable, lo que facilita la gestión de proyectos grandes y complejos. La inyección de dependencias y su estructura bien organizada permiten un desarrollo más eficiente, lo cual es esencial para un backend que necesita soportar una API robusta y en crecimiento.

---

### Decisión 6 (Proveedor de Nube)

**Título**:  
- Elección entre AWS vs Azure como proveedor de nube

**Contexto**:  
- El proyecto necesita una infraestructura en la nube escalable y flexible que soporte tanto bases de datos relacionales como no relacionales, servicios de machine learning, y capacidades de computación para gestionar las diferentes APIs del sistema. El equipo también requiere una solución con buena documentación y soporte para herramientas DevOps. Es importante que el equipo tenga acceso a una variedad de servicios de nube para diferentes necesidades, como almacenamiento, computación y redes.

**Alternativas**:  
1. **AWS (Amazon Web Services)**  
   - Ofrece una amplia gama de servicios de infraestructura, incluyendo soluciones avanzadas para almacenamiento, cómputo, machine learning y bases de datos.
   - Documentación extensa y soporte con una comunidad grande y activa.
   - Bien integrado con servicios como Lambda para serverless, S3 para almacenamiento y RDS para bases de datos relacionales.
2. **Azure**  
   - Ofrece una integración sólida con productos Microsoft, como Active Directory y herramientas de desarrollo como Visual Studio.
   - Soporta múltiples lenguajes de programación y plataformas, y tiene soluciones avanzadas para análisis de datos y machine learning.
   - Es una buena opción si ya se utilizan tecnologías Microsoft en el entorno del equipo.

**Criterios de Elección**:  
- Variedad y flexibilidad de servicios.
- Escalabilidad y facilidad de uso para los desarrolladores.
- Documentación y soporte disponible.
- Costo y facilidad de integración con el stack tecnológico existente.

**Decisión**:  
- Se elige AWS.

**Sustento**:  
- AWS ofrece una mayor variedad de servicios y flexibilidad, lo que permite cubrir todas las necesidades del proyecto, desde bases de datos y almacenamiento hasta servicios serverless y machine learning. La amplia documentación y comunidad hacen que sea más fácil de adoptar por el equipo, y sus servicios como Lambda y S3 ya son bien conocidos por el equipo. Además, AWS tiene una escalabilidad comprobada, lo cual es fundamental para un proyecto que se espera que crezca rápidamente en el tiempo.



## Módulo de Resultados

